"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Question = void 0;
const inspected_1 = require("../io/inspected");
const model_1 = require("./model");
/**
 * @desc
 *  Enables the {@link Actor} to query the system under test.
 *
 * @example <caption>A basic Question</caption>
 *  import { Actor, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { Ensure, equals } from '@serenity-js/assertions'
 *
 *  const LastItemOf = <T>(list: T[]): Question<T> =>
 *      Question.about('last item from the list', (actor: AnswersQuestions & UsesAbilities) => {
 *          return list[list.length - 1];
 *      });
 *
 *  Actor.named('Quentin').attemptsTo(
 *      Ensure.that(LastItemFrom([1,2,3]), equals(3)),
 *  );
 *
 * @example <caption>A question using the Actor's Ability to do something</caption>
 *  import { AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi } from '@serenity-js/rest'
 *
 *  const TextOfLastResponseStatus = () =>
 *      Question.about<number>(`the text of the last response status`, actor => {
 *          return CallAnApi.as(actor).mapLastResponse(response => response.statusText);
 *      });
 *
 *  @example <caption>Mapping answers to other questions</caption>
 *  import { Actor, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi, LastResponse } from '@serenity-js/rest'
 *  import { Ensure, equals } from '@serenity-js/assertions';
 *
 *  const RequestWasSuccessful = () =>
 *      Question.about<number>(`the text of the last response status`, actor => {
 *          return LastResponse.status().answeredBy(actor) === 200;
 *      });
 *
 *  const actor = Actor.named('Quentin').whoCan(CallAnApi.at('https://myapp.com/api'));
 *
 *  actor.attemptsTo(
 *      Send.a(GetRequest.to('/books/0-688-00230-7')),
 *      Ensure.that(RequestWasSuccessful(), isTrue()),
 *  );
 *
 * @see {@link Actor}
 * @see {@link Interaction}
 * @see {@link Ability}
 *
 * @abstract
 */
class Question {
    /**
     * @desc
     *  Factory method that simplifies the process of defining custom questions.
     *
     * @example
     *  const EnvVariable = (name: string) =>
     *      Question.about(`the ${ name } env variable`, actor => process.env[name])
     *
     * @static
     *
     * @param {string} description
     * @param {function(actor: AnswersQuestions & UsesAbilities): R} body
     *
     * @returns {Question<R>}
     */
    static about(description, body) {
        return (0, model_1.createAdapter)(new AnonymousQuestion(description, body));
    }
    /**
     * @desc
     *  Checks if the value is a {@link Question}.
     *
     * @static
     *
     * @param {any} maybeQuestion
     *  The value to check
     *
     * @returns {boolean}
     */
    static isAQuestion(maybeQuestion) {
        return !!maybeQuestion && !!maybeQuestion.answeredBy;
    }
    as(mapping) {
        return Question.about(`${this.toString()} as ${(0, inspected_1.inspected)(mapping, { inline: true })}`, async (actor) => {
            const answer = (await actor.answer(this));
            return mapping(answer);
        });
    }
}
exports.Question = Question;
/**
 * @package
 */
class AnonymousQuestion extends Question {
    constructor(subject, body) {
        super();
        this.subject = subject;
        this.body = body;
    }
    answeredBy(actor) {
        return this.body(actor);
    }
    /**
     * Changes the description of this question's subject
     * and produces a new instance without mutating the original one.
     *
     * @param {string} subject
     * @returns {Question<T>}
     */
    describedAs(subject) {
        this.subject = subject;
        return this;
    }
    toString() {
        return this.subject;
    }
}
//# sourceMappingURL=Question.js.map