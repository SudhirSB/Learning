"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAdapter = void 0;
const errors_1 = require("../../errors");
const inspected_1 = require("../../io/inspected");
const Interaction_1 = require("../Interaction");
const Question_1 = require("../Question");
function createAdapter(question) {
    return new Proxy(question, {
        get(target, key, receiver) {
            if (key === Symbol.toPrimitive) {
                return (_hint) => {
                    return target.toString();
                };
            }
            if (shouldReflect(target, key)) {
                return Reflect.get(target, key, receiver);
            }
            if (!shouldProxy(key)) { // ! shouldProxy
                return;
            }
            const fieldDescription = (typeof key === 'number' || /^\d+$/.test(String(key)))
                ? `[${String(key)}]` // array index
                : `.${String(key)}`; // field/method name
            // when property is invoked as a method
            function __serenityProxy(...originalParameters) {
                const parameterDescriptions = [
                    '(',
                    originalParameters.map(p => (0, inspected_1.inspected)(p, { inline: true, markQuestions: true })).join(', '),
                    ')'
                ].join('');
                const originalSubject = (0, inspected_1.inspected)(question, { inline: true, markQuestions: true });
                return createAdapter(new DynamicProp(originalSubject + fieldDescription + parameterDescriptions, async (actor) => {
                    // resolve the original answer
                    const answer = await actor.answer(target);
                    if (answer === undefined) {
                        throw new errors_1.LogicError(`${(0, inspected_1.inspected)(target, { inline: true, markQuestions: true })} is undefined, can't read property '${String(key)}'`);
                    }
                    if (typeof answer[key] !== 'function') {
                        throw new errors_1.LogicError(`${(0, inspected_1.inspected)(target, { inline: true, markQuestions: true })} does not have a method called '${String(key)}'`);
                    }
                    // convert parameters from Answerable<T> => T
                    const parameters = await (Promise.all(originalParameters.map(parameter => {
                        return actor.answer(parameter);
                    })));
                    // invoke the method call on the original answer
                    return answer[key](...parameters);
                }));
            }
            const originalSubject = (0, inspected_1.inspected)(question, { inline: true, markQuestions: true });
            __serenityProxy.subject = originalSubject + fieldDescription;
            // when property is accessed as a field
            const body = async (actor) => {
                const answer = await actor.answer(target);
                if (answer === undefined) {
                    throw new errors_1.LogicError(`${target} is undefined, can't read property "${String(key)}"`);
                }
                return answer[key];
            };
            __serenityProxy.answeredBy = body;
            __serenityProxy.performAs = body;
            __serenityProxy.toString = () => {
                return __serenityProxy.subject;
            };
            __serenityProxy.describedAs = (newSubject) => {
                __serenityProxy.subject = newSubject;
                return __serenityProxy;
            };
            __serenityProxy.as = (mapping) => {
                return Question_1.Question.about(`${__serenityProxy.subject} as ${(0, inspected_1.inspected)(mapping, { inline: true })}`, async (actor) => {
                    const answer = await actor.answer(__serenityProxy);
                    return mapping(answer);
                });
            };
            return createAdapter(__serenityProxy);
        }
    });
}
exports.createAdapter = createAdapter;
function shouldReflect(target, key) {
    const proxyKeys = ['arguments', 'caller', 'length', 'name'];
    // return the actual value
    return key in target
        // unless target is a proxy function, because proxy function has built-in .length and .name attribute that could shadow Array.length of the wrapped object
        && !(target.name === '__serenityProxy' && (proxyKeys.includes(key)));
}
function shouldProxy(key) {
    const prohibited = [
        'then', // don't proxy Promises
    ];
    return !prohibited.includes(key);
}
class DynamicProp extends Interaction_1.Interaction {
    constructor(subject, body) {
        super();
        this.subject = subject;
        this.body = body;
    }
    answeredBy(actor) {
        return this.body(actor);
    }
    async performAs(actor) {
        await this.body(actor);
    }
    as(mapping) {
        return createAdapter(new DynamicProp(`${this.subject} as ${(0, inspected_1.inspected)(mapping, { inline: true })}`, async (actor) => {
            const answer = (await actor.answer(this));
            return mapping(answer);
        }));
    }
    describedAs(subject) {
        this.subject = subject;
        return this;
    }
    toString() {
        return this.subject;
    }
}
//# sourceMappingURL=createAdapter.js.map